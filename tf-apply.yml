name: Terraform Apply
run-name: Deploy ${{ inputs.TAG }} to ${{ inputs.TF_WORKSPACE }}

on:
  # Workflow can be triggered manually
  workflow_dispatch:
    inputs:
      TF_WORKSPACE:
        type: string
        description: Which Terraform workspace would you like to deploy?
        required: true
      TAG:
        type: string
        required: true
  # Trigger on PR approval/merge
  pull_request:
    types: [closed]  # Only trigger when PR is closed (merged or closed)
  # Also trigger on manual dispatch

jobs:
  # Add approval gate for dev environment
  approval-gate:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true  # Only run when PR is merged
    outputs:
      approved: ${{ steps.check-approval.outputs.approved }}
    steps:
      - name: Check PR Approval Status
        id: check-approval
        run: |
          # Check if PR was merged (approved and merged)
          if [ "${{ github.event.pull_request.merged }}" == "true" ]; then
            echo "PR was merged - proceeding with apply"
            echo "approved=true" >> $GITHUB_OUTPUT
          else
            echo "PR was closed but not merged - skipping apply"
            echo "approved=false" >> $GITHUB_OUTPUT
            exit 0
          fi

  detect-workspace:
    needs: [approval-gate]
    if: needs.approval-gate.outputs.approved == 'true'
    runs-on: ubuntu-latest
    outputs:
      workspace: ${{ steps.detect.outputs.workspace }}
      tf_dir: ${{ steps.detect.outputs.tf_dir }}
      tf_file: ${{ steps.detect.outputs.tf_file }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Detect workspace and calculate tf_dir/tf_file
        id: detect
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger - use provided workspace
            WORKSPACE="${{ inputs.TF_WORKSPACE }}"
            echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT
            
            # Parse the provided workspace to extract tf_dir and tf_file
            IFS='-' read -r -a parts <<< "$WORKSPACE"
            TF_DIR="${parts[3]}/${parts[6]}"  # aws/networking
            ENVIRONMENT="${parts[5]}"          # dev
            TF_FILE="$ENVIRONMENT.tfvars"      # dev.tfvars
            
            echo "tf_dir=$TF_DIR" >> $GITHUB_OUTPUT
            echo "tf_file=$TF_FILE" >> $GITHUB_OUTPUT
            
          else
            # PR merge trigger - auto-detect from changes and force dev environment
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
            echo "Changed files: $CHANGED_FILES"
            
            # Determine folder and create workspace name
            if echo "$CHANGED_FILES" | grep -q "aws/iam/"; then
              FOLDER="iam"
            elif echo "$CHANGED_FILES" | grep -q "aws/networking/"; then
              FOLDER="networking"
            elif echo "$CHANGED_FILES" | grep -q "aws/core/"; then
              FOLDER="core"
            else
              echo "ERROR: No changes detected in aws/iam/, aws/networking/, or aws/core/ directories"
              exit 1
            fi
            
            # ALWAYS use dev environment for PR merges
            ENVIRONMENT="dev"
            WORKSPACE="050752625070-rtlh-di-aws-syd-$ENVIRONMENT-$FOLDER"
            TF_DIR="aws/$FOLDER"
            TF_FILE="$ENVIRONMENT.tfvars"
            
            echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT
            echo "tf_dir=$TF_DIR" >> $GITHUB_OUTPUT
            echo "tf_file=$TF_FILE" >> $GITHUB_OUTPUT
            
            echo "PR merged - Auto-detected folder: $FOLDER"
            echo "Forcing dev environment for safety"
            echo "Generated workspace: $WORKSPACE"
            echo "Terraform directory: $TF_DIR"
            echo "Terraform file: $TF_FILE"
          fi

  get-env:
    needs: [approval-gate, detect-workspace]
    if: needs.approval-gate.outputs.approved == 'true'
    uses: rio-tinto/rtlh-github-actions/.github/workflows/tf_calc_env.yml@main
    with:
      tf-workspace: ${{ needs.detect-workspace.outputs.workspace }}
      gh_repo: ${{ github.event.repository.name }}

  set-env:
    runs-on: ubuntu-latest
    needs: [approval-gate, get-env]
    if: needs.approval-gate.outputs.approved == 'true'
    environment: ${{ needs.get-env.outputs.environment }}
    outputs:
      cloud: ${{ steps.set-env.outputs.cloud }}
      aws_target_role: ${{ steps.set-env.outputs.aws_target_role }}
      region: ${{ steps.set-env.outputs.region }}
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Set Env
        id: set-env
        run: |
          echo "${{ needs.get-env.outputs.file }}"
          echo "cloud=${{ needs.get-env.outputs.cloud }}" >> $GITHUB_OUTPUT
          echo "aws_target_role=${{ vars.AWS_TARGET_ACCOUNT_ROLE_ARN }}" >> $GITHUB_OUTPUT
          echo "region=${{ vars.AWS_TARGET_REGION }}" >> $GITHUB_OUTPUT

  call-terraform-apply:
    needs: [approval-gate, detect-workspace, set-env]
    if: needs.approval-gate.outputs.approved == 'true'
    uses: rio-tinto/rtlh-github-actions/.github/workflows/tf-apply.yml@feature/us-29762
    secrets:
      RIOTINTO_ORG_TOKEN: ${{ secrets.RIOTINTO_ORG_TOKEN }}
    with:
      tf_workspace: ${{ needs.detect-workspace.outputs.workspace }}
      tf_dir: ${{ needs.detect-workspace.outputs.tf_dir }}
      tf_file: ${{ needs.detect-workspace.outputs.tf_file }}
      aws_region: ${{ needs.set-env.outputs.region }}
      gh_repo: ${{ github.event.repository.name }}
      target_role_arn: ${{ needs.set-env.outputs.aws_target_role }}
      cloud: ${{ needs.set-env.outputs.cloud }}
      tag: ${{ github.sha }}  # Use commit SHA as tag for apply
